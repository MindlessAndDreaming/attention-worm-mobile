<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="theme-color" content="#1a2a4c">
    <meta name="description" content="Worm Eater - A fun snake-like game where you control a worm that eats sprites to grow">
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#4a9bff">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Worm Eater">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Manifest -->
    <link rel="manifest" href="manifest.json">
    <!-- Icons -->
    <link rel="icon" type="image/png" sizes="192x192" href="android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="attentionWorm.png">
    <!-- iOS Safari -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Attention Worm</title>
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='40' fill='%2332c864'/><circle cx='35' cy='40' r='5' fill='white'/><circle cx='65' cy='40' r='5' fill='white'/><circle cx='35' cy='40' r='2' fill='black'/><circle cx='65' cy='40' r='2' fill='black'/></svg>">
    <script>
        (function() {
            'use strict';
            
            function isMobileDevice() {
                try {
                    // Primary checks
                    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
                    const mobileRegex = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;
                    
                    // Quick user agent check
                    if (mobileRegex.test(userAgent)) {
                        return true;
                    }
                    
                    // Touch and screen size check
                    if (('ontouchstart' in window || navigator.maxTouchPoints > 0) && 
                        (screen.width <= 768 || screen.height <= 768)) {
                        return true;
                    }
                    
                    // Orientation check
                    if (typeof window.orientation !== 'undefined') {
                        return true;
                    }
                    
                    return false;
                } catch (e) {
                    console.warn('Device detection failed:', e);
                    return false;
                }
            }
            
            function redirectIfNeeded() {
                try {
                    const isMobile = isMobileDevice();
                    const currentPath = window.location.pathname;
                    const isMobileVersion = currentPath.includes('mobile');
                    
                    // Prevent redirect loops
                    const redirectAttempted = sessionStorage.getItem('redirectAttempted');
                    if (redirectAttempted === 'true') {
                        return;
                    }
                    
                    if (isMobile && !isMobileVersion) {
                        sessionStorage.setItem('redirectAttempted', 'true');
                        window.location.href = "https://mobile.attentionworm.com";
                    } else if (!isMobile && isMobileVersion) {
                        sessionStorage.setItem('redirectAttempted', 'true');
                        window.location.href = "https://attentionworm.com";
                    }
                } catch (e) {
                    console.error('Redirect failed:', e);
                }
            }
            
            // Clear redirect flag after successful navigation
            window.addEventListener('pageshow', function() {
                sessionStorage.removeItem('redirectAttempted');
            });
            
            // Execute redirect check
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', redirectIfNeeded);
            } else {
                redirectIfNeeded();
            }
        })();
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        body {
            background: linear-gradient(135deg, #1a2a4c, #0d1b2a);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #e0e0ff;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        #game-canvas {
            background: #0f1e32;
            display: block;
            width: 100%;
            height: 100%;
        }
        #ui-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(30, 40, 70, 0.85);
            padding: 12px;
            border-radius: 10px;
            border: 2px solid #4a6fc5;
            box-shadow: 0 0 15px rgba(74, 111, 197, 0.4);
            min-width: 180px;
            z-index: 5;
        }
        #stats-panel {
            display: none;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #4a6fc5;
        }
        #score, #size, #length, #view-scale {
            font-size: 16px;
            margin: 4px 0;
            text-shadow: 0 0 3px rgba(100, 200, 255, 0.7);
        }
        #control-buttons {
            display: flex;
            gap: 8px;
            flex-direction: column;
        }
        .control-btn {
            background: linear-gradient(to bottom, #4a9bff, #2a6fd9);
            color: white;
            border: none;
            padding: 6px 10px;
            font-size: 13px;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.15s ease;
            min-height: 32px;
        }
        .control-btn:hover {
            background: linear-gradient(to bottom, #5aa5ff, #3a7fe9);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        .control-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        #pause-btn {
            background: linear-gradient(to bottom, #ff9900, #cc7a00);
        }
        #pause-btn:hover {
            background: linear-gradient(to bottom, #ffaa33, #dd8800);
        }
        #reset-btn {
            background: linear-gradient(to bottom, #ff5555, #cc3333);
        }
        #reset-btn:hover {
            background: linear-gradient(to bottom, #ff7777, #dd5555);
        }
        #food-btn {
            background: linear-gradient(to bottom, #66bb66, #449944);
        }
        #food-btn:hover {
            background: linear-gradient(to bottom, #77cc77, #55aa55);
        }
        #toggle-stats-btn {
            background: linear-gradient(to bottom, #9966cc, #7744aa);
        }
        #toggle-stats-btn:hover {
            background: linear-gradient(to bottom, #aa77dd, #8855bb);
        }
        #instructions {
            position: absolute;
            bottom: 80px;
            width: 100%;
            text-align: center;
            font-size: 16px;
            color: #a0c0ff;
            text-shadow: 0 0 5px rgba(100, 150, 255, 0.5);
            padding: 0 20px;
            z-index: 5;
        }
        /* Popup base styles */
        .popup-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 30, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10;
            cursor: pointer;
        }
        .popup-content {
            background: rgba(30, 40, 70, 0.95);
            border: 2px solid #4a6fc5;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            position: relative;
            max-width: 90%;
            text-align: center;
            cursor: default;
        }
        .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #a0c0ff;
            font-size: 24px;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            transition: background 0.2s;
        }
        .close-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        #pause-overlay {
            /* Inherits from .popup-overlay */
        }
        #pause-text {
            font-size: 42px;
            color: #6fd9ff;
            margin-bottom: 25px;
            text-shadow: 0 0 15px rgba(100, 200, 255, 0.8);
        }
        .resume-text {
            color: #a0c0ff;
            font-size: 20px;
            text-align: center;
            margin-top: 20px;
        }
        .title {
            position: absolute;
            top: 15px;
            width: 100%;
            text-align: center;
            font-size: 32px;
            color: #6fd9ff;
            text-shadow: 0 0 15px rgba(100, 200, 255, 0.8);
            letter-spacing: 2px;
            z-index: 5;
        }
        /* Mobile Joystick */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 5;
        }
        #joystick-base {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(74, 111, 197, 0.3);
            border: 2px solid #4a6fc5;
            position: relative;
            pointer-events: auto;
        }
        #joystick-thumb {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(100, 150, 255, 0.8);
            border: 2px solid #6496ff;
            position: absolute;
            top: 35px;
            left: 35px;
            transform: translate(0, 0);
            transition: transform 0.1s;
        }
        /* Install prompt */
        #install-prompt {
            /* Inherits from .popup-overlay */
        }
        #install-content {
            /* Inherits from .popup-content */
            padding: 20px;
        }
        #install-button {
            background: linear-gradient(to bottom, #4a9bff, #2a6fd9);
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }
        #install-button:hover {
            background: linear-gradient(to bottom, #5aa5ff, #3a7fe9);
        }
        @media (max-width: 768px) {
            #mobile-controls {
                display: flex;
            }
            #instructions {
                bottom: 110px;
                font-size: 14px;
            }
            #ui-overlay {
                top: 10px;
                left: 10px;
                padding: 10px;
                min-width: 150px;
            }
            #score, #size, #length, #view-scale {
                font-size: 14px;
            }
            .control-btn {
                padding: 5px 8px;
                font-size: 12px;
                min-height: 28px;
            }
            .title {
                font-size: 28px;
                top: 10px;
            }
            .resume-text {
                font-size: 18px;
            }
            .popup-content {
                padding: 20px;
            }
            #pause-text {
                font-size: 36px;
            }
        }
        @media (max-width: 480px) {
            #ui-overlay {
                min-width: 130px;
            }
            #score, #size, #length, #view-scale {
                font-size: 13px;
            }
            .control-btn {
                padding: 4px 6px;
                font-size: 11px;
                min-height: 26px;
            }
            .title {
                font-size: 24px;
            }
            .resume-text {
                font-size: 16px;
            }
            .popup-content {
                padding: 15px;
            }
            #pause-text {
                font-size: 32px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="title">WORM EATER</div>
        <canvas id="game-canvas"></canvas>
        <div id="ui-overlay">
            <div id="control-buttons">
                <button id="pause-btn" class="control-btn">Pause</button>
                <button id="reset-btn" class="control-btn">Reset</button>
                <button id="food-btn" class="control-btn">I'm Out of Food</button>
                <button id="toggle-stats-btn" class="control-btn">Show Stats</button>
            </div>
            <div id="stats-panel">
                <div id="score">Score: 0</div>
                <div id="size">Head Size: 20</div>
                <div id="length">Length: 5</div>
                <div id="view-scale">View Scale: 1.0x</div>
            </div>
        </div>
        <div id="instructions">Use the joystick to control the worm. Eat smaller sprites to grow!</div>
        <!-- Pause Overlay -->
        <div id="pause-overlay" class="popup-overlay">
            <div class="popup-content">
                <button class="close-btn">&times;</button>
                <div id="pause-text">PAUSED</div>
                <div class="resume-text">Tap or Click to Resume</div>
            </div>
        </div>
        <!-- Install Prompt -->
        <div id="install-prompt" class="popup-overlay">
            <div id="install-content" class="popup-content">
                <button class="close-btn">&times;</button>
                <div>Install Worm Eater for the best experience!</div>
                <button id="install-button">Install App</button>
            </div>
        </div>
        <!-- Mobile Joystick -->
        <div id="mobile-controls">
            <div id="joystick-base">
                <div id="joystick-thumb"></div>
            </div>
        </div>
    </div>
    <script>
        // Game constants
        const BACKGROUND_COLOR = '#0f1e32';
        const GRID_COLOR = '#1e325a';
        const WORM_COLOR = '#32c864';
        const TEXT_COLOR = '#e0e0ff';
        const SPRITE_COLORS = [
            '#ff6464', '#6496ff', '#ffc864',
            '#96ff96', '#c896ff', '#64ffff'
        ];
        // Game variables
        let canvas, ctx;
        let worm = [];
        let segments = [];
        let sprites = [];
        let score = 0;
        let gameRunning = true;
        let gamePaused = false;
        let mouseX = 0;
        let mouseY = 0;
        let headRadius = 10;
        const ORIGINAL_HEAD_RADIUS = 10;
        let viewScale = 1.0;
        let worldOffsetX = 0;
        let worldOffsetY = 0;
        let closestEdibleSprite = null;
        let statsVisible = false;
        // Worm properties - SLOWED DOWN FOR MOBILE
        const INITIAL_LENGTH = 5;
        const WORM_SPEED = 1.5; // Reduced from 3
        const MIN_HEAD_RADIUS = 5;
        const MAX_HEAD_RADIUS = 40;
        const HEAD_GROWTH_RATE = 0.3;
        // Mobile control variables
        let isMobile = true; // Force mobile mode
        let joystickData = { active: false, x: 0, y: 0 };
        let joystickBase = null;
        let joystickThumb = null;
        let joystickBaseRect = null;
        const JOYSTICK_RADIUS = 60; // Increased from 50
        const THUMB_RADIUS = 25; // Increased from 20
        // Sprite properties
        const MIN_SPRITE_RADIUS = 5;
        const MAX_SPRITE_RADIUS = 35;
        const MAX_SPRITES = 25;
        const MIN_SMALL_SPRITES = 5;
        const MIN_DRAW_RADIUS = 0.5; // Minimum radius to draw
        // PWA variables
        let deferredPrompt;
        // Initialize the game
        function init() {
            // Set up canvas
            setupCanvas();
            // Set up event listeners
            document.getElementById('food-btn').addEventListener('click', refreshSprites);
            document.getElementById('pause-btn').addEventListener('click', togglePause);
            document.getElementById('reset-btn').addEventListener('click', resetGame);
            document.getElementById('toggle-stats-btn').addEventListener('click', toggleStats);
            document.addEventListener('keydown', handleKeyDown);
            // Set up popup close handlers
            setupPopupCloseHandlers();
            // Set up mobile controls
            setupMobileJoystick();
            // Set up PWA install prompt
            setupPWA();
            // Initialize game
            initWorm();
            initSprites();
            // Start game loop
            requestAnimationFrame(gameLoop);
        }
        // Set up canvas to fit container
        function setupCanvas() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            // Set canvas size to match container
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Update mouse position reference
            mouseX = canvas.width / 2;
            mouseY = canvas.height / 2;
            // Handle window resize
            window.addEventListener('resize', handleResize);
        }
        // Handle window resize
        function handleResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        // Set up popup close handlers
        function setupPopupCloseHandlers() {
            // Pause overlay
            const pauseOverlay = document.getElementById('pause-overlay');
            const pauseCloseBtn = pauseOverlay.querySelector('.close-btn');
            pauseOverlay.addEventListener('click', (e) => {
                if (e.target === pauseOverlay) closePauseOverlay();
            });
            pauseCloseBtn.addEventListener('click', closePauseOverlay);
            // Install prompt
            const installPrompt = document.getElementById('install-prompt');
            const installCloseBtn = installPrompt.querySelector('.close-btn');
            installPrompt.addEventListener('click', (e) => {
                if (e.target === installPrompt) closeInstallPrompt();
            });
            installCloseBtn.addEventListener('click', closeInstallPrompt);
            // Install button
            document.getElementById('install-button').addEventListener('click', installApp);
        }
        // Close pause overlay
        function closePauseOverlay() {
            if (gamePaused) {
                gamePaused = false;
                document.getElementById('pause-overlay').style.display = 'none';
                document.getElementById('pause-btn').textContent = 'Pause';
            }
        }
        // Close install prompt
        function closeInstallPrompt() {
            document.getElementById('install-prompt').style.display = 'none';
        }
        // Set up mobile joystick
        function setupMobileJoystick() {
            joystickBase = document.getElementById('joystick-base');
            joystickThumb = document.getElementById('joystick-thumb');
            // Touch events for joystick
            joystickBase.addEventListener('touchstart', handleJoystickStart);
            joystickBase.addEventListener('touchmove', handleJoystickMove);
            joystickBase.addEventListener('touchend', handleJoystickEnd);
            joystickBase.addEventListener('touchcancel', handleJoystickEnd);
        }
        // Handle joystick start
        function handleJoystickStart(e) {
            e.preventDefault();
            joystickData.active = true;
            updateJoystickPosition(e.touches[0]);
        }
        // Handle joystick move
        function handleJoystickMove(e) {
            e.preventDefault();
            if (joystickData.active) {
                updateJoystickPosition(e.touches[0]);
            }
        }
        // Handle joystick end
        function handleJoystickEnd(e) {
            e.preventDefault();
            joystickData.active = false;
            joystickData.x = 0;
            joystickData.y = 0;
            // Reset thumb position
            joystickThumb.style.transform = 'translate(0, 0)';
        }
        // Update joystick position
        function updateJoystickPosition(touch) {
            const rect = joystickBase.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            // Calculate relative position
            let deltaX = touch.clientX - centerX;
            let deltaY = touch.clientY - centerY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            // Normalize and clamp to joystick radius
            if (distance > JOYSTICK_RADIUS - THUMB_RADIUS) {
                const angle = Math.atan2(deltaY, deltaX);
                deltaX = Math.cos(angle) * (JOYSTICK_RADIUS - THUMB_RADIUS);
                deltaY = Math.sin(angle) * (JOYSTICK_RADIUS - THUMB_RADIUS);
            }
            // Update joystick data
            joystickData.x = deltaX / (JOYSTICK_RADIUS - THUMB_RADIUS);
            joystickData.y = deltaY / (JOYSTICK_RADIUS - THUMB_RADIUS);
            // Update thumb position
            joystickThumb.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
        }
        // Set up PWA
        function setupPWA() {
            // Listen for install prompt
            window.addEventListener('beforeinstallprompt', (e) => {
                // Prevent Chrome 67 and earlier from automatically showing the prompt
                e.preventDefault();
                // Stash the event so it can be triggered later
                deferredPrompt = e;
                // Show the install prompt
                showInstallPrompt();
            });
        }
        // Show install prompt
        function showInstallPrompt() {
            document.getElementById('install-prompt').style.display = 'flex';
        }
        // Install app
        function installApp() {
            if (deferredPrompt) {
                // Show the install prompt
                deferredPrompt.prompt();
                // Wait for the user to respond to the prompt
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('User accepted the install prompt');
                    } else {
                        console.log('User dismissed the install prompt');
                    }
                    deferredPrompt = null;
                    closeInstallPrompt();
                });
            }
        }
        // Initialize the worm
        function initWorm() {
            worm = [];
            segments = [];
            headRadius = ORIGINAL_HEAD_RADIUS;
            viewScale = 1.0;
            worldOffsetX = 0;
            worldOffsetY = 0;
            // Create head at center of world
            const head = {
                x: 0,
                y: 0,
                radius: headRadius,
                isHead: true,
                trail: [],
                color: WORM_COLOR
            };
            worm.push(head);
            segments.push(head);
            // Create body segments
            for (let i = 1; i < INITIAL_LENGTH; i++) {
                const segment = {
                    x: -i * headRadius * 2,
                    y: 0,
                    radius: headRadius * 0.8,
                    isHead: false,
                    trail: [],
                    color: lightenColor(WORM_COLOR, -20 * i)
                };
                worm.push(segment);
                segments.push(segment);
            }
        }
        // Initialize food sprites
        function initSprites() {
            sprites = [];
            for (let i = 0; i < MAX_SPRITES; i++) {
                createSprite();
            }
            ensureSmallSprites();
        }
        // Create a new sprite
        function createSprite() {
            const radius = Math.random() * (MAX_SPRITE_RADIUS - MIN_SPRITE_RADIUS) + MIN_SPRITE_RADIUS;
            const sprite = {
                x: (Math.random() - 0.5) * 2000, // World coordinates
                y: (Math.random() - 0.5) * 2000,
                radius: radius,
                color: SPRITE_COLORS[Math.floor(Math.random() * SPRITE_COLORS.length)],
                speedX: (Math.random() - 0.5) * 2,
                speedY: (Math.random() - 0.5) * 2,
                pulse: Math.random() * Math.PI * 2,
                pulseSpeed: 0.05 + Math.random() * 0.05
            };
            sprites.push(sprite);
        }
        // Ensure there are at least MIN_SMALL_SPRITES that are smaller than or equal to worm head
        function ensureSmallSprites() {
            const head = worm[0];
            let smallSprites = 0;
            // Count current small sprites
            for (const sprite of sprites) {
                if (sprite.radius <= head.radius) {
                    smallSprites++;
                }
            }
            // Create additional small sprites if needed
            while (smallSprites < MIN_SMALL_SPRITES && sprites.length < MAX_SPRITES) {
                // Create a sprite that is smaller than or equal to the head
                const maxRadius = Math.min(head.radius, MAX_SPRITE_RADIUS);
                const minRadius = MIN_SPRITE_RADIUS;
                const radius = Math.random() * (maxRadius - minRadius) + minRadius;
                const sprite = {
                    x: (Math.random() - 0.5) * 2000,
                    y: (Math.random() - 0.5) * 2000,
                    radius: radius,
                    color: SPRITE_COLORS[Math.floor(Math.random() * SPRITE_COLORS.length)],
                    speedX: (Math.random() - 0.5) * 2,
                    speedY: (Math.random() - 0.5) * 2,
                    pulse: Math.random() * Math.PI * 2,
                    pulseSpeed: 0.05 + Math.random() * 0.05
                };
                sprites.push(sprite);
                smallSprites++;
            }
        }
        // Refresh sprites manually (renamed to "I'm Out of Food")
        function refreshSprites() {
            // Clear all sprites
            sprites = [];
            // Create new sprites
            for (let i = 0; i < MAX_SPRITES; i++) {
                createSprite();
            }
            // Ensure small sprites
            ensureSmallSprites();
        }
        // Reset and restart the game
        function resetGame() {
            // Reset game state
            score = 0;
            gamePaused = false;
            document.getElementById('pause-overlay').style.display = 'none';
            document.getElementById('pause-btn').textContent = 'Pause';
            // Reinitialize game
            initWorm();
            initSprites();
        }
        // Toggle pause state
        function togglePause() {
            gamePaused = !gamePaused;
            document.getElementById('pause-overlay').style.display = gamePaused ? 'flex' : 'none';
            document.getElementById('pause-btn').textContent = gamePaused ? 'Resume' : 'Pause';
        }
        // Toggle statistics visibility
        function toggleStats() {
            statsVisible = !statsVisible;
            document.getElementById('stats-panel').style.display = statsVisible ? 'block' : 'none';
            document.getElementById('toggle-stats-btn').textContent = statsVisible ? 'Hide Stats' : 'Show Stats';
        }
        // Handle keyboard input
        function handleKeyDown(event) {
            // P key to toggle pause
            if (event.key === 'p' || event.key === 'P') {
                togglePause();
            }
            // R key to reset game
            if (event.key === 'r' || event.key === 'R') {
                resetGame();
            }
            // S key to toggle stats
            if (event.key === 's' || event.key === 'S') {
                toggleStats();
            }
        }
        // Update game state
        function update() {
            if (!gameRunning || gamePaused) return;
            // Move worm head using mobile joystick (only method now)
            moveWormHeadMobile();
            // Move body segments to follow the previous segment
            for (let i = 1; i < worm.length; i++) {
                followSegment(worm[i], worm[i-1]);
            }
            // Move sprites
            for (const sprite of sprites) {
                moveSprite(sprite);
            }
            // Check for collisions
            checkCollisions();
            // Find closest edible sprite
            findClosestEdibleSprite();
            // Ensure there are always enough small sprites
            ensureSmallSprites();
            // Update view scale to keep head size consistent
            updateViewScale();
            // Update UI stats if visible
            if (statsVisible) {
                document.getElementById('score').textContent = `Score: ${score}`;
                document.getElementById('size').textContent = `Head Size: ${Math.floor(headRadius * 2)}`;
                document.getElementById('length').textContent = `Length: ${worm.length}`;
                document.getElementById('view-scale').textContent = `View Scale: ${viewScale.toFixed(1)}x`;
            }
        }
        // Move the worm head using mobile joystick (ONLY method now)
        function moveWormHeadMobile() {
            const head = worm[0];
            // Apply movement based on joystick data
            if (joystickData.active) {
                head.x += joystickData.x * WORM_SPEED;
                head.y += joystickData.y * WORM_SPEED;
            }
            // Update world offset to keep head centered
            worldOffsetX = head.x;
            worldOffsetY = head.y;
            // Update trail
            updateTrail(head);
        }
        // Make a segment follow the previous one
        function followSegment(segment, target) {
            // Calculate direction vector
            const dx = target.x - segment.x;
            const dy = target.y - segment.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            // Move towards target if too far
            if (distance > segment.radius + target.radius) {
                segment.x += (dx / distance) * WORM_SPEED;
                segment.y += (dy / distance) * WORM_SPEED;
            }
            // Update trail
            updateTrail(segment);
        }
        // Update segment trail
        function updateTrail(segment) {
            segment.trail.push({x: segment.x, y: segment.y});
            if (segment.trail.length > 10) {
                segment.trail.shift();
            }
        }
        // Move a sprite
        function moveSprite(sprite) {
            // Move sprite
            sprite.x += sprite.speedX;
            sprite.y += sprite.speedY;
            // Bounce off world boundaries
            const worldSize = 1000;
            if (sprite.x < -worldSize || sprite.x > worldSize) {
                sprite.speedX *= -1;
            }
            if (sprite.y < -worldSize || sprite.y > worldSize) {
                sprite.speedY *= -1;
            }
            // Update pulse
            sprite.pulse += sprite.pulseSpeed;
        }
        // Check for collisions
        function checkCollisions() {
            const head = worm[0];
            for (let i = sprites.length - 1; i >= 0; i--) {
                const sprite = sprites[i];
                const distance = Math.sqrt(
                    Math.pow(sprite.x - head.x, 2) +
                    Math.pow(sprite.y - head.y, 2)
                );
                // Check collision
                if (distance < sprite.radius + head.radius) {
                    // If sprite is smaller than or equal to worm head, eat it
                    if (sprite.radius <= head.radius) {
                        // Eat the sprite
                        eatSprite(sprite, i);
                    } else {
                        // Sprite is larger than head - lose segments
                        loseSegments();
                    }
                }
            }
            // Remove segments that are too small
            for (let i = worm.length - 1; i >= 1; i--) {
                if (worm[i].radius < 0.5) {
                    // Convert segment to sprite before removing
                    convertSegmentToSprite(worm[i]);
                    worm.splice(i, 1);
                }
            }
        }
        // Eat a sprite
        function eatSprite(sprite, index) {
            // Remove the sprite
            sprites.splice(index, 1);
            // Grow the head
            if (headRadius < MAX_HEAD_RADIUS) {
                headRadius += HEAD_GROWTH_RATE;
                worm[0].radius = headRadius;
            }
            // Add the sprite to the worm body
            addSpriteToWorm(sprite);
            // Increase score
            score += Math.floor(sprite.radius * 2);
            // Add a new sprite to maintain balance
            if (sprites.length < MAX_SPRITES) {
                createSprite();
            }
        }
        // Add a sprite to the worm body
        function addSpriteToWorm(sprite) {
            // Create a new segment based on the sprite
            const prevHead = worm[0];
            const prevSecond = worm[1] || prevHead;
            // Calculate direction from second segment to head
            const dx = prevHead.x - prevSecond.x;
            const dy = prevHead.y - prevSecond.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            // Normalize direction
            const dirX = dx / distance;
            const dirY = dy / distance;
            // Create new segment at head position
            const newSegment = {
                x: prevHead.x,
                y: prevHead.y,
                radius: Math.max(0.5, sprite.radius * 0.9), // Ensure minimum radius
                isHead: false,
                trail: [],
                color: sprite.color
            };
            // Insert new segment just behind the head
            worm.splice(1, 0, newSegment);
            segments.push(newSegment);
        }
        // Convert a segment to a sprite
        function convertSegmentToSprite(segment) {
            // Create a new sprite based on the segment
            const sprite = {
                x: segment.x,
                y: segment.y,
                radius: Math.max(0.5, segment.radius), // Ensure minimum radius
                color: segment.color,
                speedX: (Math.random() - 0.5) * 2,
                speedY: (Math.random() - 0.5) * 2,
                pulse: Math.random() * Math.PI * 2,
                pulseSpeed: 0.05 + Math.random() * 0.05
            };
            sprites.push(sprite);
        }
        // Lose segments when trying to eat a larger sprite
        function loseSegments() {
            // Remove the largest body segment (not the head)
            if (worm.length > 1) {
                // Find the largest segment (excluding head)
                let largestIndex = 1;
                let largestRadius = worm[1].radius;
                for (let i = 2; i < worm.length; i++) {
                    if (worm[i].radius > largestRadius) {
                        largestRadius = worm[i].radius;
                        largestIndex = i;
                    }
                }
                // Convert the largest segment to a sprite before removing
                convertSegmentToSprite(worm[largestIndex]);
                // Remove the largest segment
                worm.splice(largestIndex, 1);
                // Shrink head slightly as penalty
                if (headRadius > ORIGINAL_HEAD_RADIUS) {
                    headRadius = Math.max(ORIGINAL_HEAD_RADIUS, headRadius - 1);
                    worm[0].radius = headRadius;
                }
            }
        }
        // Find the closest edible sprite
        function findClosestEdibleSprite() {
            const head = worm[0];
            let closest = null;
            let closestDistance = Infinity;
            for (const sprite of sprites) {
                // Only consider edible sprites (smaller than or equal to head)
                if (sprite.radius <= head.radius) {
                    const distance = Math.sqrt(
                        Math.pow(sprite.x - head.x, 2) +
                        Math.pow(sprite.y - head.y, 2)
                    );
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closest = sprite;
                    }
                }
            }
            closestEdibleSprite = closest;
        }
        // Update view scale to keep head size consistent
        function updateViewScale() {
            // Calculate desired scale to keep head at original screen size
            const desiredScale = ORIGINAL_HEAD_RADIUS / headRadius;
            // Smooth transition to new scale
            viewScale += (desiredScale - viewScale) * 0.05;
            // Clamp scale to reasonable values
            viewScale = Math.max(0.1, Math.min(5.0, viewScale));
        }
        // Draw the game
        function draw() {
            // Clear canvas
            ctx.fillStyle = BACKGROUND_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Save context for transformations
            ctx.save();
            // Apply view transformation
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.scale(viewScale, viewScale);
            ctx.translate(-worldOffsetX, -worldOffsetY);
            // Draw grid
            drawGrid();
            // Draw sprites
            for (const sprite of sprites) {
                drawSprite(sprite);
            }
            // Draw triangle indicator to closest edible sprite
            drawTriangleIndicator();
            // Draw worm
            for (let i = worm.length - 1; i >= 0; i--) {
                drawSegment(worm[i], i === 0);
            }
            // Restore context
            ctx.restore();
        }
        // Draw grid background
        function drawGrid() {
            ctx.strokeStyle = GRID_COLOR;
            ctx.lineWidth = 1 / viewScale;
            // Calculate visible world bounds
            const left = worldOffsetX - (canvas.width/2) / viewScale;
            const right = worldOffsetX + (canvas.width/2) / viewScale;
            const top = worldOffsetY - (canvas.height/2) / viewScale;
            const bottom = worldOffsetY + (canvas.height/2) / viewScale;
            // Grid spacing based on scale
            const gridSpacing = Math.max(40, 40 / viewScale);
            // Vertical lines
            for (let x = Math.floor(left/gridSpacing) * gridSpacing; x <= right; x += gridSpacing) {
                ctx.beginPath();
                ctx.moveTo(x, top);
                ctx.lineTo(x, bottom);
                ctx.stroke();
            }
            // Horizontal lines
            for (let y = Math.floor(top/gridSpacing) * gridSpacing; y <= bottom; y += gridSpacing) {
                ctx.beginPath();
                ctx.moveTo(left, y);
                ctx.lineTo(right, y);
                ctx.stroke();
            }
        }
        // Draw triangle indicator to closest edible sprite
        function drawTriangleIndicator() {
            if (!closestEdibleSprite || worm.length === 0) return;
            const head = worm[0];
            const dx = closestEdibleSprite.x - head.x;
            const dy = closestEdibleSprite.y - head.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance === 0) return;
            // Normalize direction
            const dirX = dx / distance;
            const dirY = dy / distance;
            // Position triangle at head edge
            const posX = head.x + dirX * head.radius;
            const posY = head.y + dirY * head.radius;
            // Triangle size
            const size = 8 / viewScale;
            // Calculate triangle points
            const angle = Math.atan2(dy, dx);
            const point1 = {
                x: posX + Math.cos(angle) * size,
                y: posY + Math.sin(angle) * size
            };
            const point2 = {
                x: posX + Math.cos(angle + 2.5) * size * 0.7,
                y: posY + Math.sin(angle + 2.5) * size * 0.7
            };
            const point3 = {
                x: posX + Math.cos(angle - 2.5) * size * 0.7,
                y: posY + Math.sin(angle - 2.5) * size * 0.7
            };
            // Draw triangle
            ctx.beginPath();
            ctx.moveTo(point1.x, point1.y);
            ctx.lineTo(point2.x, point2.y);
            ctx.lineTo(point3.x, point3.y);
            ctx.closePath();
            ctx.fillStyle = closestEdibleSprite.color;
            ctx.fill();
        }
        // Draw a worm segment
        function drawSegment(segment, isHead) {
            // Skip drawing if segment is too small
            if (segment.radius < MIN_DRAW_RADIUS) return;
            // Draw trail
            for (let i = 0; i < segment.trail.length; i++) {
                const point = segment.trail[i];
                const alpha = i / segment.trail.length;
                const radius = Math.max(MIN_DRAW_RADIUS, segment.radius * alpha * 0.7);
                if (radius < MIN_DRAW_RADIUS) continue;
                ctx.beginPath();
                ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${hexToRgb(segment.color).r}, ${hexToRgb(segment.color).g}, ${hexToRgb(segment.color).b}, ${alpha * 0.3})`;
                ctx.fill();
            }
            // Draw segment
            ctx.beginPath();
            ctx.arc(segment.x, segment.y, segment.radius, 0, Math.PI * 2);
            ctx.fillStyle = segment.color;
            ctx.fill();
            // Draw segment border
            ctx.beginPath();
            ctx.arc(segment.x, segment.y, segment.radius, 0, Math.PI * 2);
            ctx.strokeStyle = darkenColor(segment.color, 30);
            ctx.lineWidth = 2 / viewScale;
            ctx.stroke();
            // Draw eyes on head
            if (isHead && worm.length > 1) {
                // Calculate direction to next segment
                const next = worm[1];
                const dx = next.x - segment.x;
                const dy = next.y - segment.y;
                const angle = Math.atan2(dy, dx);
                // Eye positions
                const eyeOffset = segment.radius * 0.5;
                const eyeRadius = segment.radius * 0.3;
                // Left eye
                const leftEyeX = segment.x + Math.cos(angle + Math.PI/4) * eyeOffset;
                const leftEyeY = segment.y + Math.sin(angle + Math.PI/4) * eyeOffset;
                // Right eye
                const rightEyeX = segment.x + Math.cos(angle - Math.PI/4) * eyeOffset;
                const rightEyeY = segment.y + Math.sin(angle - Math.PI/4) * eyeOffset;
                // Draw eyes
                ctx.beginPath();
                ctx.arc(leftEyeX, leftEyeY, eyeRadius, 0, Math.PI * 2);
                ctx.arc(rightEyeX, rightEyeY, eyeRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#f0f0f0';
                ctx.fill();
                // Draw pupils
                const pupilRadius = eyeRadius * 0.5;
                ctx.beginPath();
                ctx.arc(leftEyeX, leftEyeY, pupilRadius, 0, Math.PI * 2);
                ctx.arc(rightEyeX, rightEyeY, pupilRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#1e1e1e';
                ctx.fill();
            }
        }
        // Draw a food sprite
        function drawSprite(sprite) {
            // Skip drawing if sprite is too small
            if (sprite.radius < MIN_DRAW_RADIUS) return;
            // Pulsing effect
            const pulseSize = Math.sin(sprite.pulse) * 2;
            const radius = Math.max(MIN_DRAW_RADIUS, sprite.radius + pulseSize);
            // Draw main circle
            ctx.beginPath();
            ctx.arc(sprite.x, sprite.y, radius, 0, Math.PI * 2);
            ctx.fillStyle = sprite.color;
            ctx.fill();
            // Draw highlight
            const highlightRadius = Math.max(MIN_DRAW_RADIUS, radius * 0.4);
            const highlightX = sprite.x - radius * 0.3;
            const highlightY = sprite.y - radius * 0.3;
            ctx.beginPath();
            ctx.arc(highlightX, highlightY, highlightRadius, 0, Math.PI * 2);
            ctx.fillStyle = lightenColor(sprite.color, 40);
            ctx.fill();
        }
        // Helper function to lighten a color
        function lightenColor(color, percent) {
            // Convert hex to RGB
            let r = parseInt(color.substring(1, 3), 16);
            let g = parseInt(color.substring(3, 5), 16);
            let b = parseInt(color.substring(5, 7), 16);
            // Lighten
            r = Math.min(255, r + percent);
            g = Math.min(255, g + percent);
            b = Math.min(255, b + percent);
            // Convert back to hex
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }
        // Helper function to darken a color
        function darkenColor(color, percent) {
            // Convert hex to RGB
            let r = parseInt(color.substring(1, 3), 16);
            let g = parseInt(color.substring(3, 5), 16);
            let b = parseInt(color.substring(5, 7), 16);
            // Darken
            r = Math.max(0, r - percent);
            g = Math.max(0, g - percent);
            b = Math.max(0, b - percent);
            // Convert back to hex
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }
        // Helper function to convert hex to RGB object
        function hexToRgb(hex) {
            const r = parseInt(hex.substring(1, 3), 16);
            const g = parseInt(hex.substring(3, 5), 16);
            const b = parseInt(hex.substring(5, 7), 16);
            return { r, g, b };
        }
        // Main game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        // Start the game when the page loads
        window.addEventListener('load', init);
    </script>
     <script>
      // Register service worker
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/service-worker.js')
            .then(registration => {
              console.log('SW registered: ', registration);
            })
            .catch(registrationError => {
              console.log('SW registration failed: ', registrationError);
            });
        });
      }
    </script>
</body>
</html>